classdef KIFMM
    % OCTree Initialsie FMM Method
    %   Generate FMM class to store method parameters, The vector product 
    %   can be computed though the vectorProduct method which uses the
    %   parameter define in the creation of the class
    %
    % Inputs:
    %   tree       : Octree Struture generated by the attached OcTree file
    %   arguement  : See Optional Arguments below
    %   kernelParm   : Paramaters to be passed to the kernel 
    %                  (stored in the arguemtns structure)
    %
    % Optional Arguments:
    %   GPU          : Determins if GPU is used (0 for CPU, 1 for GPU)
    %   parThreads   : Number of threads to be used for ParFor (Default=0)
    %   blockSize    : Maximum size of Array in GB (Default = 0.2)
    %   GMRES        : Changes input shape for potentials from (n,3) to 
    %                  (3*n,1) in [x1 y1 z1 x2 y2 z2 ...]' format 
    %                  (0 for normal, 1 for new format)
    %   coronaRes    : Resolution of coronas (Default=6)
    %   coronaShells : Depth of corona (Default=2)
    %
    % Properties:
    %   tree         : Store Octree structure from OcTree
    %   arguments    : Store compuational arguments, See above
    %
    % Functions:
    %   computeVel : Compute the vector product using the KIFMM method

    
    properties
        tree;
        arguments;
    end
    
    properties (Access = private)

    end
    
    methods
        function this = KIFMM(tree,kernelPar,varargin)
            %FMM Define FMM with variables for kernel and processing
            %   Defines variable for KIFMM process
            this.tree = tree;
            IP = inputParser;
            addOptional(IP,'GPU',0);
            addOptional(IP,'parThreads',0);
            addOptional(IP,'blockSize',0.1);
            addOptional(IP,'GMRES',0);
            addOptional(IP,'coronaRes',6);
            addOptional(IP,'coronaShells',2);
            parse(IP,varargin{:});
            this.arguments = IP.Results;
            this.arguments.kernelPar = kernelPar;
        end
        
        function vel = computeVel(this, potentials)
            
            if this.arguments.GPU == 0
                uppot = upwardPassCPU(this.tree,potentials,this.arguments);
                vel = downwardPassCPU(this.tree,potentials,uppot,...
                                      this.arguments);
            else
                uppot = upwardPassGPU(this.tree,potentials,this.arguments);
                vel = downwardPassGPU(this.tree,potentials,uppot,...
                                      this.arguments);
            end
            
            
            if this.arguments.GMRES == 1
                vel = reshape(vel.',[],1);
            end
            
        end
            
    end
    
end

