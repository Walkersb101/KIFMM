classdef KIFMM
    % OCTree Initialsie FMM Method
    %   Generate FMM class to store method parameters, The vector product 
    %   can be computed though the vectorProduct method which uses the
    %   parameter define in the creation of the class
    %
    % Inputs:
    %   tree       : Octree Struture generated by the attached OcTree file
    %   arguement  : See Optional Arguments below
    %   kernelParm : Paramaters to be passed to the kernel 
    %                (stored in the arguemtns structure)
    %
    % Optional Arguments:
    %   GPU          : Determins if GPU is used (0 for CPU, 1 for GPU)
    %   parThreads   : Number of threads to be used for ParFor (Default=0)
    %   blockSize    : Maximum size of Array in GB (Default = 0.2)
    %   GMRES        : Changes input shape for potentials from (n,3) to 
    %                  (3*n,1) in [x1 y1 z1 x2 y2 z2 ...]' format 
    %                  (0 for normal, 1 for new format)
    %   coronaRes    : Resolution of coronas (Default=6)
    %   coronaShells : Depth of corona (Default=2)
    %
    % Properties:
    %   tree         : Store Octree structure from OcTree
    %   arguments    : Store compuational arguments, See above
    %
    % Functions:
    %   computeVel : Compute the vector product using the KIFMM method

    
    properties
        tree;
        arguments;
    end
    
    properties (Access = private)

    end
    
    methods
        function this = KIFMM(tree,kernelPar,varargin)
            %FMM Define FMM with variables for kernel and processing
            %   Defines variable for KIFMM process
            this.tree = tree;
            IP = inputParser;
            addOptional(IP,'GPU',0);
            addOptional(IP,'parThreads',0);
            addOptional(IP,'blockSize',0.1);
            addOptional(IP,'GMRES',0);
            addOptional(IP,'coronaRes',6);
            addOptional(IP,'coronaShells',2);
            parse(IP,varargin{:});
            this.arguments = IP.Results;
            this.arguments.kernelPar = kernelPar;
        end
        
        function vel = computeVel(this, potentials)
            %computeVel Compute velocity from given potential 
            % Compute velocity from given potential using the Kernel 
            % independent fast multipole method using the parameters given 
            % in the creation of the class.
            % 
            % Inputs:
            %   Potentials : A (N,3) array of potentials, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % Outputs:
            %   vel : A (N,3) array of velocities, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            
            if this.arguments.GMRES == 1
                potentials = reshape(potentials,3,[]).';
            end
            
            uppot = upwardPass(this.tree,potentials,this.arguments);
            vel = downwardPass(this.tree,potentials,uppot,...
                              this.arguments);
            
            
            if this.arguments.GMRES == 1
                vel = reshape(vel.',[],1);
            end

        end
        
        function vel = reducedComputeVel(this, potentials)
            %reducedComputeVel Compute velocity from given potential 
            % Compute velocity from given potential using the Kernel 
            % independent fast multipole method using the parameters given 
            % in the creation of the class. The reduced precondrttioing is
            % used where only the interations between target and potential 
            % points within the same node (and its children) are computed 
            % and all far field interactions are ignored.
            % 
            % Inputs:
            %   Potentials : A (N,3) array of potentials, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % Outputs:
            %   vel : A (N,3) array of velocities, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            
            if this.arguments.GMRES == 1
                potentials = reshape(potentials,3,[]).';
            end
            
            vel = reducedPass(this.tree,potentials,this.arguments,...
                              this.arguments.GPU);

            if this.arguments.GMRES == 1
                vel = reshape(vel.',[],1);
            end
            
        end
        
        function [pot,flag,relres,iter,resvec] = computePot(this, vel, varargin)
            
            GMRES_temp = this.arguments.GMRES;
            this.arguments.GMRES = 1;
            [pot,flag,relres,iter,resvec] = gmres(@(x) this.computeVel(x),vel,varargin{:});
            this.arguments.GMRES = GMRES_temp;
            
        end
    end
    
end

