classdef KIFMM
    % OCTree Initialsie FMM Method
    %   Generate FMM class to store method parameters, The vector product 
    %   can be computed though the computeVel method which uses the
    %   parameter define in the creation of the class
    %
    % Inputs:
    %   tree       : Octree Struture generated by the attached OcTree file
    %   arguement  : See Optional Arguments below
    %   kernelParm : Paramaters to be passed to the kernel 
    %                (stored in the arguemtns structure)
    %
    % Optional Arguments:
    %   GPU          : Determins if GPU is used (0 for CPU, 1 for GPU)
    %   parThreads   : Number of threads to be used for ParFor (Default=0)
    %   blockSize    : Maximum size of Array in GB (Default = 0.2)
    %   GMRES        : Changes input shape for potentials from (n,3) to 
    %                  (3*n,1) in [x1 y1 z1 x2 y2 z2 ...]' format 
    %                  (0 for normal, 1 for new format)
    %   format       : Changes GMRES output format to 
    %                  [x1 ... xN y1 ... yN z1 ... zN]'
    %   coronaRes    : Resolution of coronas (Default=6)
    %   coronaShells : Depth of corona (Default=1)
    %
    % Properties:
    %   tree         : Store Octree structure from OcTree
    %   arguments    : Store compuational arguments, See above
    %
    % Functions:
    %   computeVel        : Compute the vector product using the KIFMM 
    %                       method
    %   computeVelSparse  : Compute the vector product using the KIFMM 
    %                       method using a smaller equivilent surface
    % 
    %   reducedComputeVel : Compute the vector product using the KIFMM 
    %                       method where only nodes in the same node can
    %                       interact

    
    properties
        tree;
        arguments;
    end
    
    methods
        function this = KIFMM(tree,kernelPar,varargin)
            %FMM Define FMM with variables for kernel and processing
            %   Defines variable for KIFMM process
            this.tree = tree;
            IP = inputParser;
            addOptional(IP,'GPU',0);
            addOptional(IP,'parThreads',0);
            addOptional(IP,'blockSize',0.1);
            addOptional(IP,'GMRES',0);
            addOptional(IP,'coronaRes',6);
            addOptional(IP,'coronaShells',1);
            addOptional(IP,'format',1);
            parse(IP,varargin{:});
            this.arguments = IP.Results;
            this.arguments.kernelPar = kernelPar;
        end
        
        function vel = computeVel(this, potentials)
            %computeVel Compute velocity from given potential 
            % Compute velocity from given potential using the Kernel 
            % independent fast multipole method using the parameters given 
            % in the creation of the class.
            % 
            % Inputs:
            %   Potentials : A (N,3) array of potentials, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % Outputs:
            %   vel : A (N,3) array of velocities, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % If format is 2 then the GMRES structure changes to 
            % [x1 ... xN y1 ... yN z1 ... zN]'
            
            
            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    potentials = reshape(potentials,3,[]).';
                elseif this.arguments.format == 2
                    potentials = reshape(potentials,[],3);
                end
            end
            
            
            uppot = upwardPass(this.tree,potentials,this.arguments);
            vel = downwardPass(this.tree,potentials,uppot,...
                              this.arguments);
            
            
            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    vel = reshape(vel.',[],1);
                elseif this.arguments.format == 2
                    vel = reshape(vel,[],1);
                end
            end

        end
        
        function vel = computeVelSparse(this, potentials)
            %computeVelSparse Compute velocity from given potential 
            % Compute velocity from given potential using the Kernel 
            % independent fast multipole method using the parameters given
            % in the creation of the class, apart from the equivilent
            % potentials is construced of 56 points.
            % 
            % Inputs:
            %   Potentials : A (N,3) array of potentials, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % Outputs:
            %   vel : A (N,3) array of velocities, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % If format is 2 then the GMRES structure changes to 
            % [x1 ... xN y1 ... yN z1 ... zN]'
            
            
            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    potentials = reshape(potentials,3,[]).';
                elseif this.arguments.format == 2
                    potentials = reshape(potentials,[],3);
                end
            end
            
            store = [this.arguments.coronaRes,this.arguments.coronaShells];
            this.arguments.coronaRes = 4;
            this.arguments.corornaShells = 1;
            
            uppot = upwardPass(this.tree,potentials,this.arguments);
            vel = downwardPass(this.tree,potentials,uppot,...
                              this.arguments);
                          
            this.arguments.coronaRes = store(1);
            this.arguments.corornaShells = store(2);
            
            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    vel = reshape(vel.',[],1);
                elseif this.arguments.format == 2
                    vel = reshape(vel,[],1);
                end
            end

        end
        
        function vel = reducedComputeVel(this, potentials)
            %reducedComputeVel Compute velocity from given potential 
            % Compute velocity from given potential using the Kernel 
            % independent fast multipole method using the parameters given 
            % in the creation of the class. The reduced precondrttioing is
            % used where only the interations between target and potential 
            % points within the same node (and its children) are computed 
            % and all far field interactions are ignored.
            % 
            % Inputs:
            %   Potentials : A (N,3) array of potentials, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % Outputs:
            %   vel : A (N,3) array of velocities, unless GMRES
            %                option is provided then [x1 y1 z1 x2 y2 z2
            %                ...]'
            %
            % If format is 2 then the GMRES structure changes to 
            % [x1 ... xN y1 ... yN z1 ... zN]'
            
            
            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    potentials = reshape(potentials,3,[]).';
                elseif this.arguments.format == 2
                    potentials = reshape(potentials,[],3);
                end
            end
            
            vel = reducedPass(this.tree,potentials,this.arguments,...
                              this.arguments.GPU);

            if this.arguments.GMRES == 1
                if this.arguments.format == 1
                    vel = reshape(vel.',[],1);
                elseif this.arguments.format == 2
                    vel = reshape(vel,[],1);
                end
            end
            
        end
    end
end

