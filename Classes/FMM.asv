classdef FMM
    % OCTree Initialsie FMM Method
    %   Generate FMM class to store method parameters, The vector product 
    %   can be computed though the vectorProduct method which uses the
    %   parameter define in the creation of the class
    %
    % Inputs:
    %   tree       : Octree Struture generated by the attached OcTree file
    %   arguement  : See Optional Arguments below
    %
    % Optional Arguments:
    %   kernalParm   : Paramaters to be passed to the kernal
    %   GPU          : Determins if GPU is used (0 for CPU, 1 for GPU)
    %   parThreads   : Number of threads to be used for ParFor (Default=0)
    %   blockSize    : Maximum size of Array in GB (Default = 0.2)
    %   GMRES        : Changes input shape for potentials from (n,3) to 
    %                  (3*n,1) in [x1 y1 z1 x2 y2 z2 ...]' format 
    %                  (0 for normal, 1 for new format)
    %   coronaRes    : Resolution of coronas (Default=6)
    %   coronaShells : Depth of corona (Default=2)
    %
    % Properties:
    %   tree         : Store Octree structure from OcTree
    %   arguments    : Store compuational arguments, See above
    %
    % Functions:
    %   vectorProduct : Compute the vector product using the KIFMM method

    
    properties
        tree;
        kernalPar
        arguments;
    end
    
    properties (Access = private)

    end
    
    methods
        function this = FMM(tree,kernalPar,varargin)
            %FMM Define FMM with variables for kernal and processing
            %   Detailed explanation goes here
            this.tree = tree;
            this
            IP = inputParser;
            addOptional(IP,'GPU',0);
            addOptional(IP,'parThreads',0);
            addOptional(IP,'blockSize',1);
            addOptional(IP,'GMRES',0);
            addOptional(IP,'coronaRes',6);
            addOptional(IP,'coronaShells',2);
            parse(IP,varargin{:});
            this.arguments = IP.Results;
        end
        
        function vel = vectorProduct(this, potentials)
            
            if GPU == 0
                uppot = upwardPassCPU(this.tree,potentials,this.arguments);
            else
                
            end
            
            
            if this.arguments.GMRES == 1
                vel = reshape(vel.',[],1);
            end
            
        end
        
        function [uppot] = getUppot(this,potentials)
            
            uppot = upwardPass(this, potentials);
            
        end
            
    end
    
end

